# 几何问题
1. [closest_pair_of_points.cpp](./closest_pair_of_points.cpp)
    
    + n的点找出距离最近的点对的距离.

$$||pq|| = \sqrt{(p_x-q_x)^2+(p_y-q_y)^2}$$   
有很多方法,例如最简单的二层循环遍历,这里我们讨论的是O(nlohn)的方法.     
+ 根据X排序所有的点,
+ 将所有的点根据X的中点,分成两部分
+ 在两个子集中寻找最小的距离d
+ 创建新的数组strip[],纪录所有距离中线为d的点
+ 在strip中找到距离最小的值
+ 重复以上的步骤
在上述的方法中,如果strip根据y排序,我们可以在O(n)时间找到最小距离,因此我们加上排序操作,时间复杂度
是O(n(logn)^2).
如果我们添加一个数组Py[],根据y排序,在对X的中心线进行分割的时候,对应的也分割Py[],就节省了在递归中
的排序,但是我们增加的空间,这里给出O(n(logn)^2)的方法.
2. [two_line_segments_intersect.cpp](./two_line_segments_intersect.cpp)
    
    + 判断两条线段是否相交,线段用两个点给出.
    在判断线段相交之前,我们首先来定义线段的方向问题,在一个平面中的三个点,共有三种方向:
    逆时针,顺时针,共线.例如给出三个点(a,b,c),下面三种情况:[!三种情况](../assert/orientation11.png).
    使用方向判断线段相交:     
    两个线段(p1,q1)和(p2,q2)相交有且仅有下面两情况:
    * 一般情况:(p1,q1,p2)和(p1,q1,q2)有不同的方向,并且(p2,q2,p1)和(p2,q2,q1)有不同的方向
    * 特征情况(共线):(p1,q1,p2,q2)共线,而且两线段的x和y的坐标都有交叉.

    + 使用斜率来表示三个点的方向:[!图例](../assert/pic.png)    
    例如有三个点p1,p2,p3,计算其方向,我们计算a = p1和p2的斜率,b = p2和p3的斜率:     
    if a < b: 逆时针   
    if a = b: 共线    
    if a > b: 顺时针.  
    可以使用斜率的差 b - a 表示,因为     
    a = (p2.y-p1.y)/(p2.x-p1.x)     
    b = (p3.y-p2.y)/(p3.x-p2.x)     
    a > b 
    ==> (p2.y-p1.y)/(p2.x-p1.x) > (p3.y-p2.y)/(p3.x-p2.x)    
    ==>(p2.y-p1.y)*(p3.x-p2.x) > (p2.x-p1.x)*(p3.y-p2.y)        
    ==> 
    (p2.y-p1.y)*(p3.x-p2.x) - (p2.x-p1.x)*(p3.y-p2.y) 的值x,如果:   
    x>0 ==> a>b: 顺时针;   
    x=0 ==> a==b: 共线;   
    x<0 ==> a < b : 逆时针.

3. [point_inside_polygon.cpp](./point_inside_polygon.cpp)
    
        判断点在多边形之内,还是外面.在上一个文件中,我们判断两个线段时候相交.基于相交,我们有如下方法:      
    * 对与一个点p,以这个点开始,向右水平画一个无穷的线, 
    * 统计这条线与多边形相交的线段的个数k;
    * if k 是奇数,就便是点p在多边形内部; 否则p在多边形的外部.

4. [convex_hull_jarvis.cpp](./convex_hull_jarvis.cpp)     
    凸包问题,给你一组平面的的点,找到最小凸多边形包含这些点.
    + 思想很简单,也很清晰,我们知道最边上的点一定是我们需要的点.
    + 这里我们找到最左边的点,作为起始点p,逆时针找第二个点q
    + 第二个点q一定要满足,(pq)的斜率,要大于其他任一点r与p的斜率(p,r).我们可以用方向来表示,因为是逆时针找点,if(p,r,q)是逆时针,
    就更新q=r,否则不更新.如图[更新过程](../assert/jarvis.png)
    + 迭代遍历所有的点.
    + 这就是jarvis算法,最坏情况下,时间复杂度是O(n^2).

5. [convex_hull_grahamScan.cpp](./convex_hull_grahamScan.cpp)
    上一节中，我们实现的基于斜率的凸包问题，以逆时针为例，我们希望找到一个与当前点角度最远的点，
    这个角度我们可以用极角坐标来表示。下面出现的基于极角坐标的方法，时间复杂度是O(nlogn).
    + 找到左下角的点，作为第一个点。
    + 其余的点根据与第一个点的极角大小排序，越小越靠前，极角相同，距离越小越好。
    + 排序之后，检查是否有极角相同的点，移除相同极角坐标的相距p0较远的点。
    + 剩下的数组长度小于3，则没有凸包，
    + 否则，根据角度的方向，找到候选的点。[图例](./assert/Graham1.png)
    + 具体见代码
6. [point_lies_inside_triangle.cpp](./point_lies_inside_triangle.cpp)   
    判断一个点是否在三角形内，通过面积来计算。
    + 使用向量的叉乘计算面积
    + 如果点p在三角形(a,b,c)内，那么有，
    + 点p将三角形分为三个部分，如果这三个部分的和=原来的面积，则p在三角形内

7. [is_square.cpp](./is_square.cpp)     
    判断四个点是否组成正方形。通过计算距离得到，
    + 注意情况很多，建议画图穷举所有的情况。
