# SegmentTree(线段树)
    线段树主要应用在动态的更新和查询的问题,我们希望通过一种数据结构(线段树)使得查询和更新都在O(logn)时间完成.
    线段树的性质:
    1. 所有的输入元素都在叶子节点.
    2. 线段树是一个完全二叉树,共有n个叶子节点,2n-1个节点.
    3. node i的左右孩子节点分别是i*2+1,i*2+2, 其父节点是(i-1)/2.
    4. 树的高度是[log2N],需要开辟的空间是2*2^(log2n)-1.       

1. [SegmentTree(Sum of given range)](./sum_of_given_range.cpp)
    
    + 查询给定区间[l,r]直接的和,但是有多次查询,而且有动态更新.

2. [range_minimum_query.cpp](./range_minimum_query.cpp)

    + 动态查询区间的最小值,


 3. [lazy_propagation_segmentTree.cpp](./lazy_propagation_segmentTree.cpp)
    
    线段树的延迟传播,在第一节中我们更新一个值,可以用一个简单的递归函数解决,但是如果我们要更新一个区间呢,就需要调用多次这个更新函数,而且每一个都要更新在每一个区间的值.
    例如如果我们更新[2,7],就要调用6次单值更新函数.
    这里还是以区间和为例进行解释延迟传播,延迟传播是一种跟新区间值的
    优化的技术.
    思想是:在更新区间是,我们仅仅在查询的时候进行更新,对其他的延缓更新.     
    [!segment-tree1.png](../assert/segment-tree1.png)
    
    例如图中的节点27,[3-5],如果我们的更新查询是[2,5],我们就需要更新这个节点和所有的子节点.
    如果使用延迟更新,我们可以仅仅更新27这个值,通过存储更新的信息,延后更新所有子节点.我们需要创建一个lazy[]数存贮是否更新的信息.  
    初始化lazy[]={0},如果lazy[i]=0,表示未曾更新,如果lazy[i]!=0表明在查询这个节点之前需要添加到节点i的总数.
    查询的时候,需要判断这个节点是否更新,如果没有更新就先进行更新,否则直接返回.

4. [persistent_segmentTree.cpp](./persistent_segmentTree.cpp)
    
    + 持久化线段树,
    有这样的问题呢,给你一个数组和不同点的更新操作,对每一个更新操作创建一个线段树,
    需要这样的查询:    
        Q v l r: 输出第v的更新后对应的版本的[l,r]的和sum.      
    这个问题的解决方法很简单,我们可以对每一次更新后的数组建一个
    线段树定义版本0--v,但是我们每一次的时间和空间的复杂度都是
    O(nlogn);需要注意一点,每次只是更新一个点,这个点影响的值只有
    其祖先节点,原版本的线段树的其它节点不受影响,注意到这一点,我们
    只要重新创建修改的点,其它的树结构可以公共,只需要记录下来不同
    版本的线段树的节点即可.
    